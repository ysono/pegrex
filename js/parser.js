/* parser generated by jison 0.4.15 */
/*
  Returns a Parser object of the following structure:

  Parser: {
    yy: {}
  }

  Parser.prototype: {
    yy: {},
    trace: function(),
    symbols_: {associative list: name ==> number},
    terminals_: {associative list: number ==> name},
    productions_: [...],
    performAction: function anonymous(yytext, yyleng, yylineno, yy, yystate, $$, _$),
    table: [...],
    defaultActions: {...},
    parseError: function(str, hash),
    parse: function(input),

    lexer: {
        EOF: 1,
        parseError: function(str, hash),
        setInput: function(input),
        input: function(),
        unput: function(str),
        more: function(),
        less: function(n),
        pastInput: function(),
        upcomingInput: function(),
        showPosition: function(),
        test_match: function(regex_match_array, rule_index),
        next: function(),
        lex: function(),
        begin: function(condition),
        popState: function(),
        _currentRules: function(),
        topState: function(),
        pushState: function(condition),

        options: {
            ranges: boolean           (optional: true ==> token location info will include a .range[] member)
            flex: boolean             (optional: true ==> flex-like lexing behaviour where the rules are tested exhaustively to find the longest match)
            backtrack_lexer: boolean  (optional: true ==> lexer regexes are tested in order and for each matching regex the action code is invoked; the lexer terminates the scan when a token is returned by the action code)
        },

        performAction: function(yy, yy_, $avoiding_name_collisions, YY_START),
        rules: [...],
        conditions: {associative list: name ==> set},
    }
  }


  token location info (@$, _$, etc.): {
    first_line: n,
    last_line: n,
    first_column: n,
    last_column: n,
    range: [start_number, end_number]       (where the numbers are indexes into the input string, regular zero-based)
  }


  the parseError function receives a 'hash' object with these members for lexer and parser errors: {
    text:        (matched text)
    token:       (the produced terminal token, if any)
    line:        (yylineno)
  }
  while parser (grammar) errors will also provide these members, i.e. parser errors deliver a superset of attributes: {
    loc:         (yylloc)
    expected:    (string describing the set of expected tokens)
    recoverable: (boolean: TRUE when the parser has a error recovery rule available for this particular error)
  }
*/
var parser = (function(){
var o=function(k,v,o,l){for(o=o||{},l=k.length;l--;o[k[l]]=v);return o},$V0=[1,6],$V1=[1,20],$V2=[1,7,20],$V3=[1,7,16,17,18,20,21,22,24,29],$V4=[1,7,14,15,16,17,18,20,21,22,24,29],$V5=[1,28],$V6=[1,29],$V7=[1,30],$V8=[1,31],$V9=[1,32],$Va=[1,33],$Vb=[1,7,14,15,16,17,18,20,21,22,24,27,29,34],$Vc=[22,27,34];
var parser = {trace: function trace() { },
yy: {},
symbols_: {"error":2,"Pattern":3,"Disjunction":4,"Alternative_s":5,"Alternative":6,"ALT_DELIM":7,"Term_s":8,"TERM_EMPTY":9,"Term":10,"Assertion":11,"Atom":12,"Quantifier":13,"ATOM_QUANT_SHORT":14,"ATOM_QUANT_NUM":15,"ASSERTN_LB":16,"ASSERTN_WB":17,"TERM_GROUP_BEGIN":18,"ASSERTN_LOOKFWD_FLAG":19,"TERM_GROUP_END":20,"ATOM_CHAR_ANY":21,"ESCAPE_PREFIX":22,"AtomEscape":23,"CLASS_BEGIN":24,"CLASS_EMPTY":25,"ClassAtom_s":26,"CLASS_END":27,"ATOM_GROUP_NONCAPTR_BEGIN":28,"ATOM_ETC":29,"ATOM_ESCAPE_DECIMALS":30,"CharacterEscapeOrChracterClassEscape":31,"ClassAtom":32,"ClassEscape":33,"CLASS_ATOM_ETC":34,"CLASS_ATOM_ESCAPE_DECIMALS":35,"CLASS_ATOM_ESCAPE_BS":36,"ESC_DECI":37,"ESC_CTRL":38,"ESC_HEX4":39,"ESC_HEX2":40,"ESC_CLASS":41,"ESC_ETC":42,"$accept":0,"$end":1},
terminals_: {2:"error",7:"ALT_DELIM",9:"TERM_EMPTY",14:"ATOM_QUANT_SHORT",15:"ATOM_QUANT_NUM",16:"ASSERTN_LB",17:"ASSERTN_WB",18:"TERM_GROUP_BEGIN",19:"ASSERTN_LOOKFWD_FLAG",20:"TERM_GROUP_END",21:"ATOM_CHAR_ANY",22:"ESCAPE_PREFIX",24:"CLASS_BEGIN",25:"CLASS_EMPTY",27:"CLASS_END",28:"ATOM_GROUP_NONCAPTR_BEGIN",29:"ATOM_ETC",30:"ATOM_ESCAPE_DECIMALS",34:"CLASS_ATOM_ETC",35:"CLASS_ATOM_ESCAPE_DECIMALS",36:"CLASS_ATOM_ESCAPE_BS",37:"ESC_DECI",38:"ESC_CTRL",39:"ESC_HEX4",40:"ESC_HEX2",41:"ESC_CLASS",42:"ESC_ETC"},
productions_: [0,[3,1],[4,1],[5,1],[5,3],[6,1],[8,1],[8,2],[10,1],[10,1],[10,2],[13,1],[13,1],[11,1],[11,1],[11,4],[12,1],[12,2],[12,4],[12,3],[12,4],[12,1],[23,1],[23,1],[26,0],[26,2],[32,2],[32,1],[33,1],[33,1],[33,1],[31,1],[31,1],[31,1],[31,1],[31,1],[31,1]],
performAction: function anonymous(yytext, yyleng, yylineno, yy, yystate /* action[1] */, $$ /* vstack */, _$ /* lstack */) {
/* this == yyval */

var $0 = $$.length - 1;
switch (yystate) {
case 1:
return yy.b.pattern($$[$0])
break;
case 2:
this.$ = yy.b.withLoc(_$[$0], $$[$0], 'disjunction')
break;
case 3:
this.$ = [$$[$0]]
break;
case 4:
this.$ = $$[$0-2].concat($$[$0])
break;
case 5:
this.$ = yy.b.withLoc(_$[$0], $$[$0], 'alternative')
break;
case 6: case 24:
this.$ = []
break;
case 7: case 25:
this.$ = $$[$0-1].concat( yy.b.withLoc(_$[$0], $$[$0]) )
break;
case 10:
 this.$ = yy.b.quantified(
            yy.b.withLoc(_$[$0-1], $$[$0-1]),
            yy.b.withLoc(_$[$0], $$[$0], 'quantifier') ) 
break;
case 13:
this.$ = yy.b.assertionLB($$[$0])
break;
case 14:
this.$ = yy.b.assertionWB($$[$0])
break;
case 15:
this.$ = yy.b.assertionLF($$[$0-2], $$[$0-1])
break;
case 16:
this.$ = yy.b.anyChar()
break;
case 17: case 26:
this.$ = $$[$0];
break;
case 18:
this.$ = yy.b.charSet(_$[$0-1], $$[$0-3].length === 1, $$[$0-1])
break;
case 19:
this.$ = yy.b.group(true, $$[$0-1])
break;
case 20:
this.$ = yy.b.group(false, $$[$0-1])
break;
case 21: case 27:
this.$ = yy.b.specificChar($$[$0])
break;
case 22:
this.$ = yy.b.decimalsEscMaybeRefPlaceholder(_$[$0], $$[$0])
break;
case 28:
this.$ = yy.b.decimalsEsc(_$[$0], $$[$0])
break;
case 29: case 31: case 32: case 33: case 34: case 36:
this.$ = yy.b.specificCharEsc($$[$0])
break;
case 35:
this.$ = yy.b.charSetPreDefn($$[$0])
break;
}
},
table: [{3:1,4:2,5:3,6:4,8:5,9:$V0},{1:[3]},{1:[2,1]},o($V1,[2,2],{7:[1,7]}),o($V2,[2,3]),o($V2,[2,5],{10:8,11:9,12:10,16:[1,11],17:[1,12],18:[1,13],21:[1,14],22:[1,15],24:[1,16],29:[1,17]}),o($V3,[2,6]),{6:18,8:5,9:$V0},o($V3,[2,7]),o($V3,[2,8]),o($V3,[2,9],{13:19,14:$V1,15:[1,21]}),o($V3,[2,13]),o($V3,[2,14]),{4:23,5:3,6:4,8:5,9:$V0,19:[1,22],28:[1,24]},o($V4,[2,16]),{23:25,30:[1,26],31:27,37:$V5,38:$V6,39:$V7,40:$V8,41:$V9,42:$Va},{25:[1,34]},o($V4,[2,21]),o($V2,[2,4]),o($V3,[2,10]),o($V3,[2,11]),o($V3,[2,12]),{4:35,5:3,6:4,8:5,9:$V0},{20:[1,36]},{4:37,5:3,6:4,8:5,9:$V0},o($V4,[2,17]),o($V4,[2,22]),o($V4,[2,23]),o($Vb,[2,31]),o($Vb,[2,32]),o($Vb,[2,33]),o($Vb,[2,34]),o($Vb,[2,35]),o($Vb,[2,36]),o($Vc,[2,24],{26:38}),{20:[1,39]},o($V4,[2,19]),{20:[1,40]},{22:[1,43],27:[1,41],32:42,34:[1,44]},o($V3,[2,15]),o($V4,[2,20]),o($V4,[2,18]),o($Vc,[2,25]),{31:48,33:45,35:[1,46],36:[1,47],37:$V5,38:$V6,39:$V7,40:$V8,41:$V9,42:$Va},o($Vc,[2,27]),o($Vc,[2,26]),o($Vc,[2,28]),o($Vc,[2,29]),o($Vc,[2,30])],
defaultActions: {2:[2,1]},
parseError: function parseError(str, hash) {
    if (hash.recoverable) {
        this.trace(str);
    } else {
        throw new Error(str);
    }
},
parse: function parse(input) {
    var self = this, stack = [0], tstack = [], vstack = [null], lstack = [], table = this.table, yytext = '', yylineno = 0, yyleng = 0, recovering = 0, TERROR = 2, EOF = 1;
    var args = lstack.slice.call(arguments, 1);
    var lexer = Object.create(this.lexer);
    var sharedState = { yy: {} };
    for (var k in this.yy) {
        if (Object.prototype.hasOwnProperty.call(this.yy, k)) {
            sharedState.yy[k] = this.yy[k];
        }
    }
    lexer.setInput(input, sharedState.yy);
    sharedState.yy.lexer = lexer;
    sharedState.yy.parser = this;
    if (typeof lexer.yylloc == 'undefined') {
        lexer.yylloc = {};
    }
    var yyloc = lexer.yylloc;
    lstack.push(yyloc);
    var ranges = lexer.options && lexer.options.ranges;
    if (typeof sharedState.yy.parseError === 'function') {
        this.parseError = sharedState.yy.parseError;
    } else {
        this.parseError = Object.getPrototypeOf(this).parseError;
    }
    function popStack(n) {
        stack.length = stack.length - 2 * n;
        vstack.length = vstack.length - n;
        lstack.length = lstack.length - n;
    }
    _token_stack:
        function lex() {
            var token;
            token = lexer.lex() || EOF;
            if (typeof token !== 'number') {
                token = self.symbols_[token] || token;
            }
            return token;
        }
    var symbol, preErrorSymbol, state, action, a, r, yyval = {}, p, len, newState, expected;
    while (true) {
        state = stack[stack.length - 1];
        if (this.defaultActions[state]) {
            action = this.defaultActions[state];
        } else {
            if (symbol === null || typeof symbol == 'undefined') {
                symbol = lex();
            }
            action = table[state] && table[state][symbol];
        }
                    if (typeof action === 'undefined' || !action.length || !action[0]) {
                var errStr = '';
                expected = [];
                for (p in table[state]) {
                    if (this.terminals_[p] && p > TERROR) {
                        expected.push('\'' + this.terminals_[p] + '\'');
                    }
                }
                if (lexer.showPosition) {
                    errStr = 'Parse error on line ' + (yylineno + 1) + ':\n' + lexer.showPosition() + '\nExpecting ' + expected.join(', ') + ', got \'' + (this.terminals_[symbol] || symbol) + '\'';
                } else {
                    errStr = 'Parse error on line ' + (yylineno + 1) + ': Unexpected ' + (symbol == EOF ? 'end of input' : '\'' + (this.terminals_[symbol] || symbol) + '\'');
                }
                this.parseError(errStr, {
                    text: lexer.match,
                    token: this.terminals_[symbol] || symbol,
                    line: lexer.yylineno,
                    loc: yyloc,
                    expected: expected
                });
            }
        if (action[0] instanceof Array && action.length > 1) {
            throw new Error('Parse Error: multiple actions possible at state: ' + state + ', token: ' + symbol);
        }
        switch (action[0]) {
        case 1:
            stack.push(symbol);
            vstack.push(lexer.yytext);
            lstack.push(lexer.yylloc);
            stack.push(action[1]);
            symbol = null;
            if (!preErrorSymbol) {
                yyleng = lexer.yyleng;
                yytext = lexer.yytext;
                yylineno = lexer.yylineno;
                yyloc = lexer.yylloc;
                if (recovering > 0) {
                    recovering--;
                }
            } else {
                symbol = preErrorSymbol;
                preErrorSymbol = null;
            }
            break;
        case 2:
            len = this.productions_[action[1]][1];
            yyval.$ = vstack[vstack.length - len];
            yyval._$ = {
                first_line: lstack[lstack.length - (len || 1)].first_line,
                last_line: lstack[lstack.length - 1].last_line,
                first_column: lstack[lstack.length - (len || 1)].first_column,
                last_column: lstack[lstack.length - 1].last_column
            };
            if (ranges) {
                yyval._$.range = [
                    lstack[lstack.length - (len || 1)].range[0],
                    lstack[lstack.length - 1].range[1]
                ];
            }
            r = this.performAction.apply(yyval, [
                yytext,
                yyleng,
                yylineno,
                sharedState.yy,
                action[1],
                vstack,
                lstack
            ].concat(args));
            if (typeof r !== 'undefined') {
                return r;
            }
            if (len) {
                stack = stack.slice(0, -1 * len * 2);
                vstack = vstack.slice(0, -1 * len);
                lstack = lstack.slice(0, -1 * len);
            }
            stack.push(this.productions_[action[1]][0]);
            vstack.push(yyval.$);
            lstack.push(yyval._$);
            newState = table[stack[stack.length - 2]][stack[stack.length - 1]];
            stack.push(newState);
            break;
        case 3:
            return true;
        }
    }
    return true;
}};
/* generated by jison-lex 0.3.4 */
var lexer = (function(){
var lexer = ({

EOF:1,

parseError:function parseError(str, hash) {
        if (this.yy.parser) {
            this.yy.parser.parseError(str, hash);
        } else {
            throw new Error(str);
        }
    },

// resets the lexer, sets new input
setInput:function (input, yy) {
        this.yy = yy || this.yy || {};
        this._input = input;
        this._more = this._backtrack = this.done = false;
        this.yylineno = this.yyleng = 0;
        this.yytext = this.matched = this.match = '';
        this.conditionStack = ['INITIAL'];
        this.yylloc = {
            first_line: 1,
            first_column: 0,
            last_line: 1,
            last_column: 0
        };
        if (this.options.ranges) {
            this.yylloc.range = [0,0];
        }
        this.offset = 0;
        return this;
    },

// consumes and returns one char from the input
input:function () {
        var ch = this._input[0];
        this.yytext += ch;
        this.yyleng++;
        this.offset++;
        this.match += ch;
        this.matched += ch;
        var lines = ch.match(/(?:\r\n?|\n).*/g);
        if (lines) {
            this.yylineno++;
            this.yylloc.last_line++;
        } else {
            this.yylloc.last_column++;
        }
        if (this.options.ranges) {
            this.yylloc.range[1]++;
        }

        this._input = this._input.slice(1);
        return ch;
    },

// unshifts one char (or a string) into the input
unput:function (ch) {
        var len = ch.length;
        var lines = ch.split(/(?:\r\n?|\n)/g);

        this._input = ch + this._input;
        this.yytext = this.yytext.substr(0, this.yytext.length - len);
        //this.yyleng -= len;
        this.offset -= len;
        var oldLines = this.match.split(/(?:\r\n?|\n)/g);
        this.match = this.match.substr(0, this.match.length - 1);
        this.matched = this.matched.substr(0, this.matched.length - 1);

        if (lines.length - 1) {
            this.yylineno -= lines.length - 1;
        }
        var r = this.yylloc.range;

        this.yylloc = {
            first_line: this.yylloc.first_line,
            last_line: this.yylineno + 1,
            first_column: this.yylloc.first_column,
            last_column: lines ?
                (lines.length === oldLines.length ? this.yylloc.first_column : 0)
                 + oldLines[oldLines.length - lines.length].length - lines[0].length :
              this.yylloc.first_column - len
        };

        if (this.options.ranges) {
            this.yylloc.range = [r[0], r[0] + this.yyleng - len];
        }
        this.yyleng = this.yytext.length;
        return this;
    },

// When called from action, caches matched text and appends it on next action
more:function () {
        this._more = true;
        return this;
    },

// When called from action, signals the lexer that this rule fails to match the input, so the next matching rule (regex) should be tested instead.
reject:function () {
        if (this.options.backtrack_lexer) {
            this._backtrack = true;
        } else {
            return this.parseError('Lexical error on line ' + (this.yylineno + 1) + '. You can only invoke reject() in the lexer when the lexer is of the backtracking persuasion (options.backtrack_lexer = true).\n' + this.showPosition(), {
                text: "",
                token: null,
                line: this.yylineno
            });

        }
        return this;
    },

// retain first n characters of the match
less:function (n) {
        this.unput(this.match.slice(n));
    },

// displays already matched input, i.e. for error messages
pastInput:function () {
        var past = this.matched.substr(0, this.matched.length - this.match.length);
        return (past.length > 20 ? '...':'') + past.substr(-20).replace(/\n/g, "");
    },

// displays upcoming input, i.e. for error messages
upcomingInput:function () {
        var next = this.match;
        if (next.length < 20) {
            next += this._input.substr(0, 20-next.length);
        }
        return (next.substr(0,20) + (next.length > 20 ? '...' : '')).replace(/\n/g, "");
    },

// displays the character position where the lexing error occurred, i.e. for error messages
showPosition:function () {
        var pre = this.pastInput();
        var c = new Array(pre.length + 1).join("-");
        return pre + this.upcomingInput() + "\n" + c + "^";
    },

// test the lexed token: return FALSE when not a match, otherwise return token
test_match:function (match, indexed_rule) {
        var token,
            lines,
            backup;

        if (this.options.backtrack_lexer) {
            // save context
            backup = {
                yylineno: this.yylineno,
                yylloc: {
                    first_line: this.yylloc.first_line,
                    last_line: this.last_line,
                    first_column: this.yylloc.first_column,
                    last_column: this.yylloc.last_column
                },
                yytext: this.yytext,
                match: this.match,
                matches: this.matches,
                matched: this.matched,
                yyleng: this.yyleng,
                offset: this.offset,
                _more: this._more,
                _input: this._input,
                yy: this.yy,
                conditionStack: this.conditionStack.slice(0),
                done: this.done
            };
            if (this.options.ranges) {
                backup.yylloc.range = this.yylloc.range.slice(0);
            }
        }

        lines = match[0].match(/(?:\r\n?|\n).*/g);
        if (lines) {
            this.yylineno += lines.length;
        }
        this.yylloc = {
            first_line: this.yylloc.last_line,
            last_line: this.yylineno + 1,
            first_column: this.yylloc.last_column,
            last_column: lines ?
                         lines[lines.length - 1].length - lines[lines.length - 1].match(/\r?\n?/)[0].length :
                         this.yylloc.last_column + match[0].length
        };
        this.yytext += match[0];
        this.match += match[0];
        this.matches = match;
        this.yyleng = this.yytext.length;
        if (this.options.ranges) {
            this.yylloc.range = [this.offset, this.offset += this.yyleng];
        }
        this._more = false;
        this._backtrack = false;
        this._input = this._input.slice(match[0].length);
        this.matched += match[0];
        token = this.performAction.call(this, this.yy, this, indexed_rule, this.conditionStack[this.conditionStack.length - 1]);
        if (this.done && this._input) {
            this.done = false;
        }
        if (token) {
            return token;
        } else if (this._backtrack) {
            // recover context
            for (var k in backup) {
                this[k] = backup[k];
            }
            return false; // rule action called reject() implying the next rule should be tested instead.
        }
        return false;
    },

// return next match in input
next:function () {
        if (this.done) {
            return this.EOF;
        }
        if (!this._input) {
            this.done = true;
        }

        var token,
            match,
            tempMatch,
            index;
        if (!this._more) {
            this.yytext = '';
            this.match = '';
        }
        var rules = this._currentRules();
        for (var i = 0; i < rules.length; i++) {
            tempMatch = this._input.match(this.rules[rules[i]]);
            if (tempMatch && (!match || tempMatch[0].length > match[0].length)) {
                match = tempMatch;
                index = i;
                if (this.options.backtrack_lexer) {
                    token = this.test_match(tempMatch, rules[i]);
                    if (token !== false) {
                        return token;
                    } else if (this._backtrack) {
                        match = false;
                        continue; // rule action called reject() implying a rule MISmatch.
                    } else {
                        // else: this is a lexer rule which consumes input without producing a token (e.g. whitespace)
                        return false;
                    }
                } else if (!this.options.flex) {
                    break;
                }
            }
        }
        if (match) {
            token = this.test_match(match, rules[index]);
            if (token !== false) {
                return token;
            }
            // else: this is a lexer rule which consumes input without producing a token (e.g. whitespace)
            return false;
        }
        if (this._input === "") {
            return this.EOF;
        } else {
            return this.parseError('Lexical error on line ' + (this.yylineno + 1) + '. Unrecognized text.\n' + this.showPosition(), {
                text: "",
                token: null,
                line: this.yylineno
            });
        }
    },

// return next match that has a token
lex:function lex() {
        var r = this.next();
        if (r) {
            return r;
        } else {
            return this.lex();
        }
    },

// activates a new lexer condition state (pushes the new lexer condition state onto the condition stack)
begin:function begin(condition) {
        this.conditionStack.push(condition);
    },

// pop the previously active lexer condition state off the condition stack
popState:function popState() {
        var n = this.conditionStack.length - 1;
        if (n > 0) {
            return this.conditionStack.pop();
        } else {
            return this.conditionStack[0];
        }
    },

// produce the lexer rule set which is active for the currently active lexer condition state
_currentRules:function _currentRules() {
        if (this.conditionStack.length && this.conditionStack[this.conditionStack.length - 1]) {
            return this.conditions[this.conditionStack[this.conditionStack.length - 1]].rules;
        } else {
            return this.conditions["INITIAL"].rules;
        }
    },

// return the currently active lexer condition state; when an index argument is provided it produces the N-th previous condition state, if available
topState:function topState(n) {
        n = this.conditionStack.length - 1 - Math.abs(n || 0);
        if (n >= 0) {
            return this.conditionStack[n];
        } else {
            return "INITIAL";
        }
    },

// alias for begin(condition)
pushState:function pushState(condition) {
        this.begin(condition);
    },

// return the number of states currently on the stack
stateStackSize:function stateStackSize() {
        return this.conditionStack.length;
    },
options: {},
performAction: function anonymous(yy,yy_,$avoiding_name_collisions,YY_START) {
var YYSTATE=YY_START;
switch($avoiding_name_collisions) {
case 0:this.begin('ALT_BEGIN'); this.unput(yy_.yytext); return
break;
case 1:this.popState(); this.begin('TERM'); return 9
break;
case 2:popTillOutOf(this, 'TERM_GROUP'); return 20
break;
case 3:this.begin('ALT_BEGIN'); return 7
break;
case 4:return 14
break;
case 5:return 15
break;
case 6:this.begin('TERM_GROUP'); return 18
break;
case 7:this.begin('TERM_GROUP_NONCAPTR'); return
break;
case 8:this.begin('ALT_BEGIN'); this.unput(yy_.yytext); return
break;
case 9:this.begin('ALT_BEGIN'); return 19
break;
case 10:this.begin('ALT_BEGIN'); return 28
break;
case 11:return 16
break;
case 12:return 17
break;
case 13:return 21
break;
case 14:this.begin('ESCAPED_IN_ATOM'); return 22
break;
case 15:this.begin('CLASS_BEGIN'); return 24
break;
case 16:return 29
break;
case 17:this.popState(); return 30 /* parse later in grammar */
break;
case 18:this.popState(); this.begin('ESCAPED_NONDECI'); this.unput(yy_.yytext); return
break;
case 19:this.popState(); this.begin('CLASS'); return 25
break;
case 20:this.popState(); return 27
break;
case 21:this.begin('ESCAPED_IN_CLASS'); return 22
break;
case 22:return 34
break;
case 23:this.popState(); return 35 /* parse later in grammar */
break;
case 24:this.popState(); return 36
break;
case 25:this.popState(); this.begin('ESCAPED_NONDECI'); this.unput(yy_.yytext); return
break;
case 26:this.popState(); return 37 /* contrary to ecma, allow `[0-9_]` */
break;
case 27:this.popState(); return 38
break;
case 28:this.popState(); return 40
break;
case 29:this.popState(); return 39
break;
case 30:this.popState(); return 41
break;
case 31:this.popState(); return 42 /* an approx. ecma's defn is much more involved. */
break;
}
},
rules: [/^(?:.)/,/^(?:())/,/^(?:[)])/,/^(?:[|])/,/^(?:[*+?][?]?)/,/^(?:[{][0-9]+(?:[,][0-9]*)?[}][?]?)/,/^(?:[(])/,/^(?:[?])/,/^(?:.)/,/^(?:[=!])/,/^(?:[:])/,/^(?:[$^])/,/^(?:[\\][bB])/,/^(?:[\.])/,/^(?:[\\])/,/^(?:[\[][\^]?)/,/^(?:.)/,/^(?:[0-9]+)/,/^(?:.)/,/^(?:())/,/^(?:[\]])/,/^(?:[\\])/,/^(?:.)/,/^(?:[0-9]+)/,/^(?:[b])/,/^(?:.)/,/^(?:[c][0-9A-Z_a-z])/,/^(?:[fnrtv])/,/^(?:[x][0-9A-Fa-f]{2})/,/^(?:[u][0-9A-Fa-f]{4})/,/^(?:[dDsSwW])/,/^(?:[^cxu])/],
conditions: {"ESCAPED_NONDECI":{"rules":[26,27,28,29,30,31],"inclusive":false},"ESCAPED_IN_CLASS":{"rules":[23,24,25],"inclusive":false},"CLASS_BEGIN":{"rules":[19],"inclusive":false},"CLASS":{"rules":[20,21,22],"inclusive":false},"ESCAPED_IN_ATOM":{"rules":[17,18],"inclusive":false},"TERM_GROUP_NONCAPTR":{"rules":[9,10],"inclusive":false},"TERM_GROUP":{"rules":[7,8],"inclusive":false},"TERM":{"rules":[2,3,4,5,6,11,12,13,14,15,16],"inclusive":false},"ALT_BEGIN":{"rules":[1],"inclusive":false},"INITIAL":{"rules":[0],"inclusive":true}}
});
function popTillOutOf(lexer, state) {
    var st
    do {
        st = lexer.popState()
    } while (st !== state)
};
return lexer;
})();
parser.lexer = lexer;
function Parser () {
  this.yy = {};
}
Parser.prototype = parser;parser.Parser = Parser;
return new Parser;
})();


if (typeof require !== 'undefined' && typeof exports !== 'undefined') {
exports.parser = parser;
exports.Parser = parser.Parser;
exports.parse = function () { return parser.parse.apply(parser, arguments); };
exports.main = function commonjsMain(args) {
    if (!args[1]) {
        console.log('Usage: '+args[0]+' FILE');
        process.exit(1);
    }
    var source = require('fs').readFileSync(require('path').normalize(args[1]), "utf8");
    return exports.parser.parse(source);
};
if (typeof module !== 'undefined' && require.main === module) {
  exports.main(process.argv.slice(1));
}
};(function() {
    'use strict'

    var terms_s = []
    var numCapturedGroups = 0

    var builders = {
        withLoc: function(loc, arg, builderName) {
            var token = builderName
                ? builders[builderName](arg)
                : arg
            if (token instanceof Array) {
                // The concept of location is valid with one token only.
                // Not an error if token can be an array or an obj
                // namely ClassEscape
                return token
            }
            token.textLoc = [
                loc.first_column,
                loc.last_column
            ]
            return token
        },

        pattern: function(disj) {
            function terminus() {
                return {
                    type: 'Terminus'
                }
            }
            return {
                type: 'Pattern',
                roots: [
                    terminus(),
                    disj,
                    terminus()
                ]
            }
        },
        disjunction: function(alts) {
            return {
                type: 'Disjunction',
                alternatives: alts
            }
        },
        alternative: function(terms) {
            var result = {
                type: 'Alternative',
                terms: terms
            }
            if (! terms.length) {
                result.hint = 'Matches zero-length string.'
            }

            // save so we can parse decimalsEscMaybeRefPlaceholder later
            terms_s.push(terms)

            return result
        },

        quantifier: function(token) {
            if (token[0] !== '{') {
                return {
                    type: 'Quantifier',
                    min: token[0] === '+' ? 1 : 0,
                    max: token[0] === '?' ? 1 : Infinity,
                    greedy: token.length < 2
                }
            }
            var matched = token.match(/{(\d+)(?:(,)(\d*))?}(\?)?/)
            var result = {
                type: 'Quantifier',
                min: Number(matched[1]),
                max: matched[3]
                    ? Number(matched[3])
                    : matched[2]
                        ? Infinity
                        : Number(matched[1]),
                greedy: ! matched[4]
            }
            if (result.min > result.max) {
                throw new Error(
                    'Min must be <= to max. Invalid pair: '
                    + [result.min, result.max])
            }
            return result
        },
        quantified: function(target, quantifier) {
            return {
                type: 'Quantified',
                target: target,
                quantifier: quantifier,
                textLoc: [target.textLoc[0], quantifier.textLoc[1]]
            }
        },

        assertionLB: function(token) {
            var atBeg = token === '^'
            var sepChars = [
                'New Line (\\n)',
                'Carriage Return (\\r)',
                'Line Separator (\\u2028)',
                'Paragraph Separator (\\u2029)'
            ]
            var hint = [
                'Asserts that immediately',
                atBeg ? 'left' : 'right',
                'of this position is a "line separation".',
                'Matches the zero-length string between the "line separation" and the char',
                atBeg ? 'after' : 'before',
                'it.',
                'In the regular single-line mode, a "line separation" is the beginning or the end of the input.',
                'In multi-line mode, it also includes these chars:',
                sepChars.join(', '),
            ].join(' ') + '.'
            return {
                type: 'Assertion',
                assertion: (atBeg ? 'Start' : 'End') + ' of Line',
                atBeg: atBeg,
                hint: hint
            }
        },
        assertionWB: function(token) {
            var atWb = token[1] === 'b'
            var wc = '(a word char i.e. \\w)'
            var nwc = '(a non-word char i.e. \\W or the start (^) or the end ($) of a line)'
            var hint = [
                'Matches the zero-length string between',
                wc,
                'and',
                atWb ? nwc : wc
            ].join(' ') + '.'
            return {
                type: 'Assertion',
                assertion: (atWb ? '' : 'Non-') + 'Word Boundary',
                atWb: atWb,
                hint: hint
            }
        },
        assertionLF: function(flag, disj) {
            return {
                type: 'Grouped Assertion',
                assertion: (flag === '=' ? 'Positive' : 'Negative')
                    + ' Look-Forward',
                grouped: disj
            }
        },

        /* mockNumer must be used by token creator to prevent
            modifying the numCapturedGroups state */
        group: function(isCapturing, disj, mockNumber) {
            return {
                type: 'Group',
                number: isCapturing
                    ? typeof mockNumber === 'number'
                        ? mockNumber
                        : ++numCapturedGroups
                    : undefined,
                grouped: disj
            }
        },

        charSetAnyOtherChar: function() {
            return {
                type: 'Any Other Char'
            }
        },
        charSetRange: function(from, to) {
            if (from.display > to.display) {
                throw new Error(
                    'The beginning char must be <= to the ending char.'
                    + ' Invalid pair: ' + [from.display, to.display])
            }
            return {
                type: 'Range of Chars',
                range: [from, to],
                textLoc: from.textLoc && to.textLoc
                    ? [from.textLoc[0], to.textLoc[1]]
                    : undefined
            }
        },
        charSet: function(loc, inclusive, items, predefinedDisplay) {
            // TODO test: start with ^, ^-, -^, -, [\d-x]
            
            // convert some of 'Specific Char's to 'Range of Chars'.
            // more readable to do it here than in lex.
            var i, item, prevItem, nextItem, replacement
            for (i = 1; i < items.length - 1; i++) {
                item = items[i]
                prevItem = items[i - 1]
                nextItem = items[i + 1]
                if (item.type === 'Specific Char' && item.display === '-'
                    && prevItem.type === 'Specific Char'
                    && nextItem && nextItem.type === 'Specific Char') {

                    replacement = builders.charSetRange(prevItem, nextItem)
                    items.splice(i - 1, 3, replacement)

                    // On the next loop, want i to point to 2 elms ahead of replacement.
                    // replacement is now at (i - 1) -> 2 ahead is (i + 1)
                    // compensate for i++ by subtr 1 -> don't move i
                }
            }

            var toggleInclusive = {
                'Any Other Char': function() {
                    // do nothing since we're not visually distinguishing in/excl.
                },
                'Specific Char': function(parentIncl, sc) {
                    sc.inclusive = parentIncl
                },
                'Range of Chars': function(parentIncl, r) {
                    r.inclusive = parentIncl
                    r.range.forEach(function(sc) {
                        toggleInclusive[sc.type](parentIncl, sc)
                    })
                },
                'Set of Chars': function(parentIncl, s) {
                    var myIncl = parentIncl === s.inclusive
                    s.inclusive = myIncl
                    s.possibilities.forEach(function(p) {
                        toggleInclusive[p.type](myIncl, p)
                    })
                }
            }
            items.forEach(function(item) {
                toggleInclusive[item.type](inclusive, item)
            })

            var result = {
                type: 'Set of Chars',
                inclusive: inclusive,
                possibilities: items,
                predefinedDisplay: predefinedDisplay
            }
            if (loc) {
                // if exclusive, need to specify loc for the nested set
                //     (non-fake, see below) so that add/replace works at the
                //     right location. Also, have to keep `^` out.
                // for consistency, specify loc if inclusive too. For inclusive,
                //     result.textLoc will be overriden later, with a range that
                //     will include the brackets. So set innerTextLoc.
                // but if it's the empty exclusive, `[^]`, need textLoc for
                //     to allow the convenience of `addNeighborArrows`.
                //     so keep textLoc too.
                // clear as mud?
                builders.withLoc(loc, result)
                result.innerTextLoc = result.textLoc
            }
            if (! inclusive) {
                result = {
                    type: 'Set of Chars',
                    inclusive: true,
                    possibilities: [
                        result,
                        builders.charSetAnyOtherChar()
                    ],
                    nonSemantic: true // consider the wrapper Set a fake one
                }
            }
            return result
        },
        charSetPreDefn: function(key) {
            var inclusive = key >= 'a'

            function makeRange(fromChar, toChar) {
                var range = builders.charSetRange(
                    builders.specificChar(fromChar),
                    builders.specificChar(toChar)
                )
                return range
            }
            var possibilities = {
                d: function() {
                    return [makeRange('0', '9')]
                },
                s: function() {
                    return [
                        builders.specificCharEsc('n'),
                        builders.specificCharEsc('r'),
                        builders.specificCharEsc('u2028'),
                        builders.specificCharEsc('u2029'),
                        builders.specificCharEsc('t'),
                        builders.specificCharEsc('v'),
                        builders.specificCharEsc('f'),
                        builders.specificChar(' '),
                        builders.specificCharEsc('u00a0')
                    ]
                },
                w: function() {
                    return [
                        makeRange('0', '9'),
                        makeRange('A', 'Z'),
                        builders.specificChar('_'),
                        makeRange('a', 'z')
                    ]
                }
            }[key.toLowerCase()]()

            var hint = {
                d: 'Decimal',
                D: 'Non-Decimal',
                s: 'Whitepace',
                S: 'Non-Whitespace',
                w: 'Word Char',
                W: 'Non-Word Char'
            }[key]

            var result = builders.charSet(
                null, // if pre defn is exclusive, its nested Set of Chars
                    // won't be selectable, and that's ok
                inclusive,
                possibilities,
                '\\' + key
            )
            result.hint = hint
            return result
        },

        anyChar: function() {
            return {
                type: 'Any Char'
            }
        },
        specificChar: function(display) {
            display = {
                ' ': 'Space Char'
            }[display] || display
            return {
                type: 'Specific Char',
                display: display
            }
        },
        specificCharEsc: function(key, hint) {
            var map = {
                b: 'Backspace',
                c: 'Control Char',
                f: 'Form Feed',
                n: 'New Line',
                r: 'Carriage Return',
                t: 'Horizontal Tab',
                v: 'Vertical Tab',
                x: 'Hexadecimal Notation',
                u: 'Hexadecimal Notation',
                'u2028': 'Line Separator',
                'u2029': 'Paragraph Separator',
                'u00a0': 'Nbsp'
            }
            hint = hint || map[key] || map[key[0]]
            return {
                type: 'Specific Char',
                display: (hint ? '\\' : '') + key,
                hint: hint
            }
        },

        decimalsEscMaybeRefPlaceholder: function(loc, decimals) {
            return {
                type: 'decimalsEscMaybeRefPlaceholder',
                maxCapturedGroupNum: numCapturedGroups,
                decimals: decimals,
                loc: loc
            }
        },
        decimalsEscMaybeRef: function(placeholder) {
            /* returns an array of specificChar or specificCharEsc
                or Reference or Quantified */
            /* TODO test 
                placeholder -> specificCharEsc and specificChar
                placeholder -> Reference
                Quantified -> [specific* , Quantified specific] // \1+, \8+, \18+, \88+
                Quantified -> [Quantified Reference]
            */
            function parse(p) {
                var intVal = Number(p.decimals)

                var isRef = p.decimals[0] > '0'
                    && intVal <= numCapturedGroups
                if (! isRef) {
                    return builders.decimalsEsc(p.loc, p.decimals)
                }

                // Contrary to [ecma](http://www.ecma-international.org/ecma-262/5.1/#sec-15.10.2.9),
                // allow non-ref interpretation.

                var isBack = intVal <= p.maxCapturedGroupNum
                var hint = isBack
                    ? ['Warning: A Back Reference will match with an empty string if'
                        ,'the target group has not been captured by the time this reference is expected.'
                        ,'In practice, any group that is 1) outside the root-level Alternative (the portion'
                        ,'demarcated by '|') that this Back Reference belongs to or 2) inside a Look-Forward'
                        ,'Assertion will have not been captured.'].join(' ')
                    : ['Because its target group will never have been captured,'
                        ,'a Forward Reference always matches with an empty string.'].join(' ')
                return [{
                    type: 'Reference',
                    number: intVal,
                    isBack: isBack,
                    hint: hint,
                    textLoc: [
                        p.loc.first_column - 1, // -1 for the `\`
                        p.loc.last_column
                    ]
                }]
            }
            if (placeholder.type !== 'Quantified') {
                return parse(placeholder)
            }
            var items = parse(placeholder.target)
            var quantified = builders.quantified(
                items.slice(-1)[0], placeholder.quantifier)
            items.splice(-1, 1, quantified)
            return items
        },
        decimalsEsc: function(loc, decimals) {
            // Contrary to [ecma](http://www.ecma-international.org/ecma-262/5.1/#sec-15.10.2.11),
            // support octal notations other than `\0`.

            var evalled = window.eval("'\\" + decimals + "'") // it's safe.
            var hasOctal = evalled[0] !== decimals[0]

            var loc0 = loc.first_column                

            var item0Len = hasOctal
                ? decimals.length - evalled.length + 1
                : 1
            var item0 = builders.specificCharEsc(
                    decimals.slice(0, item0Len),
                    hasOctal ? 'Octal Notation' : null)
            item0.textLoc = [
                loc0 - 1, // -1 for the `\`
                loc0 + item0Len
            ]

            var item1Loc = item0.textLoc[1]
            var items = [item0]
                .concat(
                    evalled.slice(1).split('').map(function(c, i) {
                        var item = builders.specificChar(c)
                        item.textLoc = [
                            item1Loc + i,
                            item1Loc + i + 1
                        ]
                        return item
                    })
                )
            return items
        }
    } // end of var builders
    parser.yy.b = builders

    // note: we could assign yy.parseError to customize error to include text location,
    //     but location isn't helpful.

    parser.parse = (function(orig) {
        function postParse() {
            terms_s.forEach(function(terms) {
                function splice() {
                    var args = [i, 1].concat(replacement)
                    Array.prototype.splice.apply(terms, args)
                }
                var i, term, replacement
                for (i = 0; i < terms.length; i++) {
                    term = terms[i]

                    var isPlaceholder =
                        term.type === 'decimalsEscMaybeRefPlaceholder'
                        || (term.type === 'Quantified'
                            && term.target.type === 'decimalsEscMaybeRefPlaceholder')
                    if (isPlaceholder) {
                        replacement = builders.decimalsEscMaybeRef(term)
                        splice()

                        // point i to the last elm of replacement
                        i = i + replacement.length - 1
                    }
                }
            })
        }
        return function() {
            try {
                var parsed = orig.apply(this, arguments)
                postParse()
                return parsed
            } finally {
                // reset these values that make parser stateful
                terms_s.length = 0
                numCapturedGroups = 0
            }
        }
    })(parser.parse)

})()
